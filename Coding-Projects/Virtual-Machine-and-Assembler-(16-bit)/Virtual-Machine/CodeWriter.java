/**
 * Author: Ben Vargas
 * Course: CS220 - Computer Architecture and Assembly Language
 * Professor: Nery Chapeton-Lamas
 * Project: Virtual Machine Translator (HACK Architecture)
 */

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;

/**
 * Object used to handle file output (.asm files)
 */
public class CodeWriter {

    // INSTANCE VARIABLES

    String mOutputFileName;
    PrintWriter outputFile = null; //keep compiler happy
    int labelCounter;

    /**
     * Standard Constructor for CodeWriter
     * <p>
     *     CodeWriter object is initialized with this constructor. Label Counter starts at 1.
     * </p>
     * Precondition: Valid .asm file name is passed to method (not error checked in CodeWriter)
     * Postcondition: OutputStream is instantiated, and label counter instantiated to the value 1
     * @param outputFileName - filename passed to constructor is used to initiate a file output stream
     */
    public CodeWriter(String outputFileName) {
        setFileName(outputFileName);
        this.mOutputFileName = outputFileName;
        labelCounter = 1;
    }

    /**
     * setFileName
     * <p>
     *     Method used to instantiate a PrintWriter object, and opening a file output stream
     *     to a .asm output file.
     * </p>
     * @param fileName - fileName passed from constructor
     * Precondition: valid filename is passed to method
     * Postcondition: PrintWriter member object will be instantiated, pointing to fileName file output stream
     */
    public void setFileName(String fileName) {
        try{
            outputFile = new PrintWriter(new FileOutputStream(fileName));
        } catch (IOException e) {
            System.err.println(e.getMessage());
            System.err.println("Could not open output file " + fileName);
            System.err.println("Run program again, make sure you have write permissions, etc.");
            System.exit(0);
        }
    }

    /**
     * writeCommand
     * <p>
     *     Master method used to initialize series of helper methods that will ultimately
     *     generate Assembly code for a given command passed to this method. This is the method
     *     that should be used from outside this object. Actual translation occurs in helper methods
     *     of this object.
     * </p>
     * Precondition: Valid command is in .vm file being parsed. In this version, only Arithmetic, Push, Pop implemented
     * Postcondition: Helper methods will be initialized, and assembly code will be written to the output stream
     * @param command - String command that has been parsed and passed to the method
     * @param segment - keyword used to reference a location in memory. Only relevant for push/pop
     * @param index - index to adjust memory location as necessary. Only relevant for push/pop
     * @param commandType - command type of the passed String command
     * @throws IllegalArgumentException - if commandType is NOT Arithmetic or Push/Pop (other types not in this ver.)
     */
    public void writeCommand(String command, String segment, int index, int commandType) {

        if (commandType == Parser.C_ARITHMETIC) {
            writeArithmetic(command);
        } else if (commandType == Parser.C_PUSH || commandType == Parser.C_POP) {
            if (index < 0) {
                throw new IllegalArgumentException("Invalid index: " + index);
            }
            writePushPop(command, segment, index, commandType);
        } else if (commandType == Parser.C_NOCOMMAND) {
            // DO NOTHING, BLANK LINE
        } else { // other commands not yet implemented
            throw new IllegalArgumentException();
            // STUB CASE TODO
            // Only Arithmetic, Push, and Pop are within scope of the current deliverable.
            // Other commands may or may not be implemented at a future date.
        }
    }

    /**
     * writeArithmetic
     * <p>
     *     Helper method used to <b>route</b> the command translation to the correct
     *     helper method. There are four possible cases (otherwise exception is thrown).
     *     <ol>
     *         <li>Case 1: "add", "sub", "or", "and"</li>
     *         <li>Case 2: "gt", "lt", "eq" (comparison)</li>
     *         <li>Case 3: "neg"</li>
     *         <li>Case 4: "not"</li>
     *     </ol>
     * </p>
     * Precondition: valid command is generated by compiler
     * Postcondition: correct helper method will be initialized
     * @param command - command passed to CodeWriter object from writeCommand()
     * @throws IllegalArgumentException - if cases are violated
     */
    private void writeArithmetic(String command) throws IllegalArgumentException {
        if (command.equals("add") || command.equals("sub") || command.equals("or") || command.equals("and")) {
            writeAddSubAndOr(command);
        } else if (command.equals("gt") || command.equals("lt") || command.equals("eq")) {
            writeComparison(command);
        } else if (command.equals("neg")) {
            writeNeg(command);
        } else if (command.equals("not")) {
            writeNot(command);
        } else {
            throw new IllegalArgumentException();
        }
    }

    /**
     * writeAddSubAndOr
     * <p>
     *     Method writes the assembly code required to execute the 'add', 'sub', 'and' and
     *     'or' Arithmetic commands.
     * </p>
     * Precondition: Valid syntax and command is generated by compiler
     * Postcondition: Assembly instructions for Arithmetic commands in method description are written
     * to output file
     * @param command - String command passed into the writeCommand() method
     * @throws IllegalArgumentException - if invalid command is passed
     */
    private void writeAddSubAndOr(String command) throws IllegalArgumentException {
        outputFile.println("@SP");
        outputFile.println("AM=M-1");
        outputFile.println("D=M");
        outputFile.println("A=A-1");

        if (command.equals("add")) {
            outputFile.println("M=M+D");
        } else if (command.equals("sub")) {
            outputFile.println("M=M-D");
        } else if (command.equals("and")) {
            outputFile.println("M=M&D");
        } else if (command.equals("or")) {
            outputFile.println("M=M|D");
        } else {
            throw new IllegalArgumentException();
        }
    }

    /**
     * writeComparison
     * <p>
     *     Method writes the assembly code required to execute the 'eq', 'lt', and 'gt'
     *     Arithmetic vm commands.
     * </p>
     * @param command - command passed to method that has previously been parsed
     * Precondition: "lt", "gt", or "eq" are passed to method
     * Postcondition: Assembly instructions for comparison are written to output .asm file
     * @throws IllegalArgumentException - if invalid comparison is passed to method
     */
    private void writeComparison(String command) {
        // LABELS MUST BE UNIQUE IN ORDER TO JUMP TO CORRECT ROM ADDRESS.
        // By default, the CodeWriter constructor initializes labelCounter to 1
        int firstLabel, secondLabel;

        firstLabel = labelCounter;
        secondLabel = labelCounter + 1;

        labelCounter += 2;

        // part 1 of 3 (always consistent for comparison operations)
        outputFile.println("@SP");
        outputFile.println("A=M-1");
        outputFile.println("A=A-1");
        outputFile.println("D=M");
        outputFile.println("A=A+1");
        outputFile.println("D=D-M");
        outputFile.println("@_" + firstLabel);

        // part 2 of 3 (each has a different comparison condition)
        switch (command) {
            case "eq":
                outputFile.println("D;JEQ");
                break;
            case "gt":
                outputFile.println("D;JGT");
                break;
            case "lt":
                outputFile.println("D;JLT");
                break;
            default:
                throw new IllegalArgumentException("Illegal Comparison Statement: " + command);
        }

        // part 3 of 3 (always consistent for comparison operations)
        outputFile.println("D=0");
        outputFile.println("@_" + secondLabel);
        outputFile.println("0;JMP");
        outputFile.println("(_" + firstLabel + ")"); //label for TRUE
        outputFile.println("D=-1");
        outputFile.println("(_" + secondLabel + ")"); // label for FALSE
        outputFile.println("@SP");
        outputFile.println("AM=M-1");
        outputFile.println("A=A-1");
        outputFile.println("M=D");
    }

    /**
     * writeNeg
     * <p>
     *     Writes assembly instruction to NEGATE the value at the top of the stack (SP).
     * </p>
     * @param command - command passed to method that has been previously parsed
     * Precondition: "neg" is string passed to method
     * Postcondition: instructions for "neg" are written to output .asm file
     */
    private void writeNeg(String command) {
        outputFile.println("D=0");
        outputFile.println("@SP");
        outputFile.println("A=M-1");
        outputFile.println("M=D-M");
    }

    /**
     * writeNot
     * <p>
     *     Writes assembly instruction to NOT the value at the top of the stack (SP).
     * </p>
     * @param command - command passed to method that has been previously parsed
     * Precondition: "not" is string passed to method
     * Postcondition: instructions for "not" are written to output .asm file
     */
    private void writeNot(String command) {
        outputFile.println("@SP");
        outputFile.println("A=M-1");
        outputFile.println("M=!M");
    }

    /**
     * writePushPop
     * <p>
     *     Method used to route to either writePush() or writePop().
     * </p>
     * Precondition: valid push or pop syntax was generated by Compiler
     * Postcondition: Assembly instructions for push or pop command is written to .asm output file
     * @param pushOrPop - command passed to method
     * @param segment - segment passed to method from parsed line
     * @param index - index passed to method from parsed line
     * @param commandType - commandType passed to method from parsed command
     * @throws IllegalArgumentException - if neither push or pop (should not occur)
     */
    private void writePushPop(String pushOrPop, String segment, int index, int commandType)
                                                                        throws IllegalArgumentException {

        if (commandType == Parser.C_PUSH) {
            writePush(segment, index);
        } else if (commandType == Parser.C_POP) {
            writePop(segment,index);
        } else {
            throw new IllegalArgumentException();
        }
    }

    /**
     * writePush
     * <p>
     *     This method is used to write statements to the CodeWriter's output stream
     *     to locate, retrieve (from segment[index] (segment, index are passed in
     *     as parameters) and 'push' a value to the top of the stack.
     * </p>
     * Precondition: Valid use of segment and index is passed from compiler
     * Postcondition: If invalid command is passed, written assembly code will not function as intended.
     * @param segment - String keyword signaling what value in memory to push
     * @param index - int modifier to the segment passed as an argument (except for constant/pointer)
     * @throws IllegalArgumentException - if invalid segment is passed
     */
    private void writePush(String segment, int index) throws IllegalArgumentException {

        // goal for each case is to get the data referenced by seg/index to D reg, and push D
        switch (segment) {
            case "argument":
                outputFile.println("@" + index);
                outputFile.println("D=A");
                outputFile.println("@ARG");
                outputFile.println("A=M+D");
                outputFile.println("D=M");
                break;
            case "local":
                outputFile.println("@" + index);
                outputFile.println("D=A");
                outputFile.println("@LCL");
                outputFile.println("A=M+D");
                outputFile.println("D=M");
                break;
            case "static":
                outputFile.println("@" + mOutputFileName + "." + index);
                outputFile.println("D=M");
                break;
            case "constant":
                outputFile.println("@" + index);
                outputFile.println("D=A");
                break;
            case "this":
                outputFile.println("@" + index);
                outputFile.println("D=A");
                outputFile.println("@THIS");
                outputFile.println("A=M+D");
                outputFile.println("D=M");
                break;
            case "that":
                outputFile.println("@" + index);
                outputFile.println("D=A");
                outputFile.println("@THAT");
                outputFile.println("A=M+D");
                outputFile.println("D=M");
                break;
            case "pointer": // assumes index is 0 or 1
                if (index == 0) {
                    outputFile.println("@THIS");
                } else {
                    outputFile.println("@THAT");
                }
                outputFile.println("D=M");
                break;
            case "temp":
                outputFile.println("@" + index);
                outputFile.println("D=A");
                outputFile.println("@R5");
                outputFile.println("A=A+D");
                outputFile.println("D=M");
                break;
            default:
                throw new IllegalArgumentException("Incorrect Segment in writePush:" + segment);
        }

        writePushD();
    }

    /**
     * writePushD
     * <p>
     *     Simple method that reduces redundancy in codebase. The assembly
     *     instruction to push the value inside the D register is written
     *     to the output file.
     * </p>
     * Precondition: D register has been stored with the desired value, proper file output stream is created
     * Postcondition: Commands to push the value in the D register written to .asm file
     */
    private void writePushD() {
        outputFile.println("@SP");
        outputFile.println("AM=M+1");
        outputFile.println("A=A-1");
        outputFile.println("M=D");
    }

    /**
     * writePop
     * <p>
     *     This method is used to write statements to the CodeWriter's output stream
     *     to pop and store a value to a segment[index] (segment, index are passed in
     *     as parameters).
     * </p>
     * @param segment - String keyword signaling where to save the popped value in memory
     * @param index - an index modifier to the segment passed as an argument (except for pointer & constant)
     * @throws IllegalArgumentException - If invalid segment is passed (e.g., constant, or word not shown)
     */
    private void writePop(String segment, int index) throws IllegalArgumentException{
        /*
         * Goal for each case:
         * 1. Pop top of stack and adjust SP
         * 2. Store popped value into segment[index] as appropriate
         */
        switch (segment) {
            case "argument":
                outputFile.println("@ARG");
                writeAddIndexPopThenStoreFromReservedLocation(segment, index);
                break;
            case "local":
                outputFile.println("@LCL");
                writeAddIndexPopThenStoreFromReservedLocation(segment, index);
                break;
            case "static":
                writePopTopOfStackToD();
                outputFile.println("@" + mOutputFileName + "." + index);
                outputFile.println("M=D");
                break;
            case "constant": // popping a constant is not a logical/valid statement
                throw new IllegalArgumentException();
            case "this":
                outputFile.println("@THIS");
                writeAddIndexPopThenStoreFromReservedLocation(segment, index);
                break;
            case "that":
                outputFile.println("@THAT");
                writeAddIndexPopThenStoreFromReservedLocation(segment, index);
                break;
            case "pointer": // assumes index is 0 or 1
                if (index == 0) {
                    writePopTopOfStackToD();
                    outputFile.println("@THIS");
                    outputFile.println("M=D");
                } else {
                    writePopTopOfStackToD();
                    outputFile.println("@THAT");
                    outputFile.println("M=D");
                }
                break;
            case "temp":
                outputFile.println("@R5");
                writeAddIndexPopThenStoreFromReservedLocation(segment, index);
                break;
            default:
                throw new IllegalArgumentException("Incorrect Segment in writePop:" + segment);
        }

    }

    /**
     * writeAddIndexPopThenStoreFromReservedLocation
     * <p>
     *     Method used to isolate the behavior of adding an index
     *     to the <b>address</b> inside a reserved location in memory,
     *     saving the summed address to a local variable 'X', popping
     *     the top of stack to D reg (with a helper method), then
     *     finally storing the popped value to the saved memory address.
     * </p>
     * Precondition: Specified reserved location in memory is already written in writePop()
     * Postcondition: Desired popped value will be stored at desired location
     * @param index - number of placed in memory to increment from address stored in reserved location.
     */
    public void writeAddIndexPopThenStoreFromReservedLocation(String segment, int index){
        if (segment.equals("temp")) {
            outputFile.println("D=A");
        } else {
            outputFile.println("D=M");
        }
        outputFile.println("@" + index);
        outputFile.println("D=D+A");
        outputFile.println("@X");
        outputFile.println("M=D");
        writePopTopOfStackToD();
        outputFile.println("@X");
        outputFile.println("A=M");
        outputFile.println("M=D");
    }

    /**
     * writePopTopOfStackToD
     * <p>
     *     Helper method to clarify a key part of popping. Specifically, the three statements
     *     below efficiently pop the top of the stack and save the value popped to the D register.
     * </p>
     * Precondition: D does not contain a needed piece of data
     * Postcondition: D will contain the value that was at the top of the stack before the method was called
     */
    public void writePopTopOfStackToD() {
        outputFile.println("@SP");
        outputFile.println("AM=M-1");
        outputFile.println("D=M");
    }

    /**
     * close
     * <p>
     *     Simple method to close the output stream. Wrapper method for the PrintWriter.close() method.
     * </p>
     * Precondition: n/a
     * Postcondition: PrintWriter member variable is closed
     * @throws IllegalStateException - if PrintWriter is closed without ever being opened
     */
    public void close() throws IllegalStateException {
        if(outputFile != null) {
            outputFile.close();
        } else {
            throw new IllegalStateException("PrintWriter was not initialized properly when writing .asm.");
        }

    }
}
